
> nextn@0.1.0 test
> jest

PASS tests/unit/export-stage-recovery.test.ts
  ‚óè Console

    console.warn
      [ExportRecovery] Reset stuck export stage to idle: export-publish

      30 |           error: undefined,
      31 |         };
    > 32 |         console.warn('[ExportRecovery] Reset stuck export stage to idle:', stage.id);
         |                 ^
      33 |       } else if (state.output) {
      34 |         // Non-export stages with output: Reset to completed to preserve results
      35 |         result[stage.id] = {

      at src/lib/export-stage-recovery.ts:32:17
          at Array.forEach (<anonymous>)
      at resetStuckExportStages (src/lib/export-stage-recovery.ts:21:19)
      at Object.<anonymous> (tests/unit/export-stage-recovery.test.ts:29:42)

    console.log
      [ExportRecovery] Recovered 1 stuck stages

      at resetStuckExportStages (src/lib/export-stage-recovery.ts:57:13)

    console.warn
      [ExportRecovery] Reset stuck stage to idle (no output): ai-stage

      48 |           error: undefined,
      49 |         };
    > 50 |         console.warn('[ExportRecovery] Reset stuck stage to idle (no output):', stage.id);
         |                 ^
      51 |       }
      52 |       recoveredStages++;
      53 |     }

      at src/lib/export-stage-recovery.ts:50:17
          at Array.forEach (<anonymous>)
      at resetStuckExportStages (src/lib/export-stage-recovery.ts:21:19)
      at Object.<anonymous> (tests/unit/export-stage-recovery.test.ts:54:42)

    console.log
      [ExportRecovery] Recovered 1 stuck stages

      at resetStuckExportStages (src/lib/export-stage-recovery.ts:57:13)

    console.warn
      [ExportRecovery] Reset stuck export stage to idle: export-publish

      30 |           error: undefined,
      31 |         };
    > 32 |         console.warn('[ExportRecovery] Reset stuck export stage to idle:', stage.id);
         |                 ^
      33 |       } else if (state.output) {
      34 |         // Non-export stages with output: Reset to completed to preserve results
      35 |         result[stage.id] = {

      at src/lib/export-stage-recovery.ts:32:17
          at Array.forEach (<anonymous>)
      at resetStuckExportStages (src/lib/export-stage-recovery.ts:21:19)
      at Object.<anonymous> (tests/unit/export-stage-recovery.test.ts:99:42)

    console.log
      [ExportRecovery] Recovered 1 stuck stages

      at resetStuckExportStages (src/lib/export-stage-recovery.ts:57:13)

PASS src/workflows/press-release/__tests__/prompt-quality.test.ts
PASS src/lib/__tests__/workflow-loader.test.ts
PASS src/workflows/press-release/__tests__/workflow-execution.test.ts
PASS tests/unit/ai-stage-execution-flow.test.ts
PASS src/workflows/press-release/__tests__/workflow-config.test.ts
PASS src/workflows/press-release/__tests__/template-validation.test.ts
FAIL src/components/wizard/stage-output-area.test.tsx
  ‚óè StageOutputArea ‚Ä∫ renders Markdown output correctly

    TestingLibraryElementError: Unable to find an element with the text: # Hello This is markdown. (normalized from '# Hello
    This is markdown.'). This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<div[39m
            [33mclass[39m=[32m"relative"[39m
          [36m>[39m
            [36m<div>[39m
              [0m# Hello
    This is markdown.[0m
            [36m</div>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      76 |     });
      77 |     // MarkdownRenderer mock will just render the content in a div
    > 78 |     expect(screen.getByText(markdownContent)).toBeInTheDocument();
         |                   ^
      79 |   });
      80 |
      81 |   it('renders JSON output correctly using JsonRenderer', () => {

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:78:19)

  ‚óè StageOutputArea ‚Ä∫ renders JSON output correctly using JsonRenderer

    TestingLibraryElementError: Unable to find an element with the text: { "key": "value", "nested": { "number": 123 } } (normalized from '{
      "key": "value",
      "nested": {
        "number": 123
      }
    }'). This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<div[39m
            [33mclass[39m=[32m"relative"[39m
          [36m>[39m
            [36m<pre>[39m
              [0m{
      "key": "value",
      "nested": {
        "number": 123
      }
    }[0m
            [36m</pre>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      85 |       stageState: { ...defaultStageState, output: jsonData },
      86 |     });
    > 87 |     expect(screen.getByText(JSON.stringify(jsonData, null, 2))).toBeInTheDocument();
         |                   ^
      88 |   });
      89 |
      90 |   describe('Thinking Steps Display', () => {

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:87:19)

  ‚óè StageOutputArea ‚Ä∫ Thinking Steps Display ‚Ä∫ renders structured thinking steps (tool request/response/log) if provided in stageState

    TestingLibraryElementError: Unable to find an element with the text: Thinking Process. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<div[39m
            [33mclass[39m=[32m"relative"[39m
          [36m>[39m
            [36m<p[39m
              [33mclass[39m=[32m"whitespace-pre-wrap font-body"[39m
            [36m>[39m
              [0mFinal Answer is 3.[0m
            [36m</p>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      112 |       });
      113 |
    > 114 |       expect(screen.getByText('Thinking Process')).toBeInTheDocument();
          |                     ^
      115 |
      116 |       // Check for tool request rendering
      117 |       expect(screen.getByText('Tool Call:')).toBeInTheDocument();

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:114:21)

  ‚óè StageOutputArea ‚Ä∫ Chat Enabled Output Area ‚Ä∫ renders chat history if chatEnabled and history exists

    TestingLibraryElementError: Unable to find an element with the text: user. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<div[39m
            [33mclass[39m=[32m"relative"[39m
          [36m>[39m
            [36m<p[39m
              [33mclass[39m=[32m"whitespace-pre-wrap font-body"[39m
            [36m>[39m
              [0mHello User![0m
            [36m</p>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      247 |       });
      248 |
    > 249 |       expect(screen.getByText('user')).toBeInTheDocument(); // Role
          |                     ^
      250 |       expect(screen.getByText('Hello AI!')).toBeInTheDocument();
      251 |       expect(screen.getByText('model')).toBeInTheDocument(); // Role
      252 |       expect(screen.getByText('Hello User!')).toBeInTheDocument();

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:249:21)

  ‚óè StageOutputArea ‚Ä∫ Chat Enabled Output Area ‚Ä∫ renders "No messages yet" if chatEnabled and no history

    TestingLibraryElementError: Unable to find an element with the text: No messages yet. Send a message to start the chat.. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<p[39m
          [33mclass[39m=[32m"text-sm text-muted-foreground"[39m
        [36m>[39m
          [0mNo output yet for this stage.[0m
        [36m</p>[39m
      [36m</div>[39m
    [36m</body>[39m

      258 |         stageState: { ...defaultStageState, stageId: chatStageConfig.id, status: 'idle', chatHistory: [] },
      259 |       });
    > 260 |       expect(screen.getByText('No messages yet. Send a message to start the chat.')).toBeInTheDocument();
          |                     ^
      261 |     });
      262 |
      263 |     it('renders streaming output if status is running and currentStreamOutput exists', () => {

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:260:21)

  ‚óè StageOutputArea ‚Ä∫ Chat Enabled Output Area ‚Ä∫ renders streaming output if status is running and currentStreamOutput exists

    TestingLibraryElementError: Unable to find an element with the text: Once upon a time.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<p[39m
          [33mclass[39m=[32m"text-sm text-muted-foreground"[39m
        [36m>[39m
          [0mAI is generating output...[0m
        [36m</p>[39m
      [36m</div>[39m
    [36m</body>[39m

      273 |         },
      274 |       });
    > 275 |       expect(screen.getByText("Once upon a time...")).toBeInTheDocument(); // "..." is added by component
          |                     ^
      276 |     });
      277 |      it('renders "AI is thinking..." if status is running and no currentStreamOutput for chat', () => {
      278 |       renderComponent({

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:275:21)

  ‚óè StageOutputArea ‚Ä∫ Chat Enabled Output Area ‚Ä∫ renders "AI is thinking..." if status is running and no currentStreamOutput for chat

    TestingLibraryElementError: Unable to find an element with the text: AI is thinking.... This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<p[39m
          [33mclass[39m=[32m"text-sm text-muted-foreground"[39m
        [36m>[39m
          [0mAI is generating output...[0m
        [36m</p>[39m
      [36m</div>[39m
    [36m</body>[39m

      280 |         stageState: { ...defaultStageState, stageId: chatStageConfig.id, status: 'running', chatHistory: [] },
      281 |       });
    > 282 |       expect(screen.getByText('AI is thinking...')).toBeInTheDocument();
          |                     ^
      283 |     });
      284 |   });
      285 | });

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-output-area.test.tsx:282:21)

FAIL src/components/wizard/stage-input-area.test.tsx
  ‚óè Console

    console.error
      Warning: An update to StageInputArea inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at /Users/franzenzenhofer/dev/franzai-writer/src/components/wizard/stage-input-area.tsx:33:6

      149 |       reader.onloadend = () => {
      150 |         const base64String = reader.result as string;
    > 151 |         setImagePreviewUrl(base64String); // For preview
          |         ^
      152 |         // Pass base64 string for Genkit part
      153 |         // Store the preview URL and the base64 string for submission
      154 |         onInputChange(stage.id, "userInput", {

      at printWarning (node_modules/react-dom/cjs/react-dom.development.js:86:30)
      at error (node_modules/react-dom/cjs/react-dom.development.js:60:7)
      at warnIfUpdatesNotWrappedWithActDEV (node_modules/react-dom/cjs/react-dom.development.js:27628:9)
      at scheduleUpdateOnFiber (node_modules/react-dom/cjs/react-dom.development.js:25547:5)
      at dispatchSetState (node_modules/react-dom/cjs/react-dom.development.js:16708:7)
      at Object.reader.onloadend (src/components/wizard/stage-input-area.tsx:151:9)
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:88:24)

    console.error
      Warning: An update to StageInputArea inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at /Users/franzenzenhofer/dev/franzai-writer/src/components/wizard/stage-input-area.tsx:33:6

      186 |             fileUri: null, // Clear any previous URI
      187 |           });
    > 188 |           setDocumentInfo(`Text content loaded: ${file.name}`);
          |           ^
      189 |           setUploadProgress(null);
      190 |         };
      191 |         reader.onerror = () => {

      at printWarning (node_modules/react-dom/cjs/react-dom.development.js:86:30)
      at error (node_modules/react-dom/cjs/react-dom.development.js:60:7)
      at warnIfUpdatesNotWrappedWithActDEV (node_modules/react-dom/cjs/react-dom.development.js:27628:9)
      at scheduleUpdateOnFiber (node_modules/react-dom/cjs/react-dom.development.js:25547:5)
      at dispatchSetState (node_modules/react-dom/cjs/react-dom.development.js:16708:7)
      at Object.reader.onload (src/components/wizard/stage-input-area.tsx:188:11)
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:223:24)

    console.error
      Warning: An update to StageInputArea inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */
      
      This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act
          at /Users/franzenzenhofer/dev/franzai-writer/src/components/wizard/stage-input-area.tsx:33:6

      187 |           });
      188 |           setDocumentInfo(`Text content loaded: ${file.name}`);
    > 189 |           setUploadProgress(null);
          |           ^
      190 |         };
      191 |         reader.onerror = () => {
      192 |             setUploadProgress(`Error reading text file.`);

      at printWarning (node_modules/react-dom/cjs/react-dom.development.js:86:30)
      at error (node_modules/react-dom/cjs/react-dom.development.js:60:7)
      at warnIfUpdatesNotWrappedWithActDEV (node_modules/react-dom/cjs/react-dom.development.js:27628:9)
      at scheduleUpdateOnFiber (node_modules/react-dom/cjs/react-dom.development.js:25547:5)
      at dispatchSetState (node_modules/react-dom/cjs/react-dom.development.js:16708:7)
      at Object.reader.onload (src/components/wizard/stage-input-area.tsx:189:11)
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:223:24)

    console.error
      Upload error: Error: Server upload error
          at handleDocumentChange (/Users/franzenzenhofer/dev/franzai-writer/src/components/wizard/stage-input-area.tsx:212:17)

      224 |         setUploadProgress('Upload successful!');
      225 |       } catch (error: any) {
    > 226 |         console.error("Upload error:", error);
          |                 ^
      227 |         setDocumentInfo(`Upload failed for ${file.name}: ${error.message}`);
      228 |         setUploadProgress(`Upload failed: ${error.message}`);
      229 |         // Clear partial input state on error

      at handleDocumentChange (src/components/wizard/stage-input-area.tsx:226:17)

  ‚óè StageInputArea ‚Ä∫ Document Input Type ‚Ä∫ calls onInputChange with document metadata and content for .txt file and shows info

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

      "doc-stage",
      "userInput",
      Object {
        "documentName": "test.txt",
        "documentSize": 11,
        "documentType": "text/plain",
        "fileContent": "Hello World",
    +   "fileUri": null,
      },

    Number of calls: 1

    Ignored nodes: comments, script, style
    [36m<html>[39m
      [36m<head />[39m
      [36m<body>[39m
        [36m<div>[39m
          [36m<div[39m
            [33mclass[39m=[32m"space-y-4"[39m
          [36m>[39m
            [36m<label[39m
              [33mclass[39m=[32m"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"[39m
              [33mfor[39m=[32m"doc-stage-document-input"[39m
            [36m>[39m
              [0mUpload Document[0m
            [36m</label>[39m
            [36m<input[39m
              [33maccept[39m=[32m".pdf,.doc,.docx,.txt,.md"[39m
              [33mclass[39m=[32m"flex h-10 w-full rounded-md border border-input px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm bg-background"[39m
              [33mid[39m=[32m"doc-stage-document-input"[39m
              [33mtype[39m=[32m"file"[39m
            [36m/>[39m
            [36m<div[39m
              [33mclass[39m=[32m"mt-2 p-2 border rounded bg-muted text-xs text-muted-foreground"[39m
            [36m>[39m
              [36m<p>[39m
                [0mText content loaded: test.txt[0m
              [36m</p>[39m
            [36m</div>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</body>[39m
    [36m</html>[39m

      225 |
      226 |       await waitFor(() => {
    > 227 |         expect(mockOnInputChange).toHaveBeenCalledWith(documentStage.id, 'userInput', {
          |                                   ^
      228 |           documentName: 'test.txt',
      229 |           documentType: 'text/plain',
      230 |           documentSize: testFile.size,

      at src/components/wizard/stage-input-area.test.tsx:227:35
      at runWithExpensiveErrorDiagnosticsDisabled (node_modules/@testing-library/dom/dist/config.js:47:12)
      at checkCallback (node_modules/@testing-library/dom/dist/wait-for.js:124:77)
      at checkRealTimersCallback (node_modules/@testing-library/dom/dist/wait-for.js:118:16)
      at Timeout.task [as _onTimeout] (node_modules/jsdom/lib/jsdom/browser/Window.js:579:19)

  ‚óè StageInputArea ‚Ä∫ Document Input Type ‚Ä∫ calls fetch to /api/files/upload for non-txt file and updates state on success

    ReferenceError: setImmediate is not defined

      253 |         fireEvent.change(fileInput, { target: { files: [testFile] } });
      254 |         // Allow promises from async handler to resolve
    > 255 |         await new Promise(resolve => setImmediate(resolve));
          |                                      ^
      256 |       });
      257 |
      258 |       expect(global.fetch).toHaveBeenCalledWith('/api/files/upload', expect.any(Object));

      at src/components/wizard/stage-input-area.test.tsx:255:38
      at src/components/wizard/stage-input-area.test.tsx:255:15
      at node_modules/@testing-library/react/dist/act-compat.js:48:24
      at act (node_modules/react/cjs/react.development.js:2512:16)
      at node_modules/@testing-library/react/dist/act-compat.js:47:25
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:252:16)

  ‚óè StageInputArea ‚Ä∫ Document Input Type ‚Ä∫ handles fetch error during file upload for non-txt file

    ReferenceError: setImmediate is not defined

      281 |       await act(async () => {
      282 |         fireEvent.change(fileInput, { target: { files: [testFile] } });
    > 283 |         await new Promise(resolve => setImmediate(resolve));
          |                                      ^
      284 |       });
      285 |
      286 |       expect(global.fetch).toHaveBeenCalledWith('/api/files/upload', expect.any(Object));

      at src/components/wizard/stage-input-area.test.tsx:283:38
      at src/components/wizard/stage-input-area.test.tsx:283:15
      at node_modules/@testing-library/react/dist/act-compat.js:48:24
      at act (node_modules/react/cjs/react.development.js:2512:16)
      at node_modules/@testing-library/react/dist/act-compat.js:47:25
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:281:16)

  ‚óè StageInputArea ‚Ä∫ Document Input Type ‚Ä∫ clears document info when file input is cleared

    Unable to find an element with the text: File: test.txt (text/plain, 5 bytes). This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<label[39m
            [33mclass[39m=[32m"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"[39m
            [33mfor[39m=[32m"doc-stage-document-input"[39m
          [36m>[39m
            [0mUpload Document[0m
          [36m</label>[39m
          [36m<input[39m
            [33maccept[39m=[32m".pdf,.doc,.docx,.txt,.md"[39m
            [33mclass[39m=[32m"flex h-10 w-full rounded-md border border-input px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm bg-background"[39m
            [33mid[39m=[32m"doc-stage-document-input"[39m
            [33mtype[39m=[32m"file"[39m
          [36m/>[39m
          [36m<p[39m
            [33mclass[39m=[32m"text-xs text-muted-foreground mt-1"[39m
          [36m>[39m
            [0mPreparing to upload...[0m
          [36m</p>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      305 |       // Select a file first
      306 |       fireEvent.change(fileInput, { target: { files: [testFile] } });
    > 307 |       await waitFor(() => {
          |                    ^
      308 |         expect(screen.getByText(`File: test.txt (text/plain, ${testFile.size} bytes)`)).toBeInTheDocument();
      309 |       });
      310 |

      at waitForWrapper (node_modules/@testing-library/dom/dist/wait-for.js:163:27)
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:307:20)

  ‚óè StageInputArea ‚Ä∫ Document Input Type ‚Ä∫ re-renders document info if stageState.userInput.documentName is already populated

    TestingLibraryElementError: Unable to find an element with the text: File: old-doc.pdf (application/pdf, 12345 bytes). This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.

    Ignored nodes: comments, script, style
    [36m<body>[39m
      [36m<div>[39m
        [36m<div[39m
          [33mclass[39m=[32m"space-y-4"[39m
        [36m>[39m
          [36m<label[39m
            [33mclass[39m=[32m"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"[39m
            [33mfor[39m=[32m"doc-stage-document-input"[39m
          [36m>[39m
            [0mUpload Document[0m
          [36m</label>[39m
          [36m<input[39m
            [33maccept[39m=[32m".pdf,.doc,.docx,.txt,.md"[39m
            [33mclass[39m=[32m"flex h-10 w-full rounded-md border border-input px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm bg-background"[39m
            [33mid[39m=[32m"doc-stage-document-input"[39m
            [33mtype[39m=[32m"file"[39m
          [36m/>[39m
          [36m<div[39m
            [33mclass[39m=[32m"mt-2 p-2 border rounded bg-muted text-xs text-muted-foreground"[39m
          [36m>[39m
            [36m<p>[39m
              [0mSelected: old-doc.pdf (application/pdf, 12345 bytes)[0m
            [36m</p>[39m
          [36m</div>[39m
        [36m</div>[39m
      [36m</div>[39m
    [36m</body>[39m

      330 |         }
      331 |       });
    > 332 |       expect(screen.getByText(`File: old-doc.pdf (application/pdf, 12345 bytes)`)).toBeInTheDocument();
          |                     ^
      333 |     });
      334 |   });
      335 |

      at Object.getElementError (node_modules/@testing-library/dom/dist/config.js:37:19)
      at node_modules/@testing-library/dom/dist/query-helpers.js:76:38
      at node_modules/@testing-library/dom/dist/query-helpers.js:52:17
      at node_modules/@testing-library/dom/dist/query-helpers.js:95:19
      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:332:21)

  ‚óè StageInputArea ‚Ä∫ Chat Enabled Input Area ‚Ä∫ renders textarea with fewer rows and different placeholder if chatEnabled

    expect(element).toHaveAttribute("rows", "3") // element.getAttribute("rows") === "3"

    Expected the element to have attribute:
      rows="3"
    Received:
      rows="8"

      350 |       const textarea = screen.getByPlaceholderText('Enter chat message'); // Placeholder comes from stage.description
      351 |       expect(textarea).toBeInTheDocument();
    > 352 |       expect(textarea).toHaveAttribute('rows', '3');
          |                        ^
      353 |     });
      354 |   });
      355 |

      at Object.<anonymous> (src/components/wizard/stage-input-area.test.tsx:352:24)

Test Suites: 2 failed, 7 passed, 9 total
Tests:       13 failed, 104 passed, 117 total
Snapshots:   0 total
Time:        3.133 s
Ran all test suites.
