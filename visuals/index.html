<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dreamâ€‘Kaleidoâ€‘Flow</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block;width:100%;height:100%}
  #info{
    position:fixed;left:8px;bottom:8px;padding:.4em .6em;
    font:12px/1.3 monospace;color:#eee;background:#0009;border-radius:4px;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="info">ğŸŒ€ Dreamâ€‘Kaleidoâ€‘Flow â€“ move the mouse / tap to tweak</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx     = canvas.getContext('2d');
  let w, h, dpr, midX, midY;

  // Parameters that drift over time â€“ small pointer input nudges them.
  const parms = {
    slices: 12,            // radial symmetry
    circles: 8,            // base motifs each slice is mirrored from
    baseRadius: 0.35,      // fraction of min(canvas) â€“ updated live
    swirlSpeed: 0.25,
    hueSpeed: 40,
    sizeMod: 0.18
  };

  // Resize handler â€“ keeps canvas crisp on HiDPI.
  function resize() {
    dpr   = window.devicePixelRatio || 1;
    w     = canvas.clientWidth  * dpr;
    h     = canvas.clientHeight * dpr;
    canvas.width  = w;
    canvas.height = h;
    ctx.setTransform(dpr,0,0,dpr,0,0);     // revert logical coords to CSS pixels
    midX  = w / (2*dpr);
    midY  = h / (2*dpr);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Pointer tweaks: drag horizontally to change swirl, vertically to change slice count.
  window.addEventListener('pointermove', e => {
    const normX = (e.clientX / window.innerWidth  - .5) * 2;
    const normY = (e.clientY / window.innerHeight - .5) * 2;
    parms.swirlSpeed = 0.05 + Math.abs(normX) * 0.6;
    parms.slices     = 6 + Math.floor(Math.abs(normY) * 18); // 6â€“24 slices
  }, {passive:true});

  // Draw one â€œmotifâ€ that will be rotated / mirrored around the center.
  function drawMotif(t) {
    const {circles, baseRadius, sizeMod, hueSpeed} = parms;
    for (let i = 0; i < circles; i++) {
      const angle   = i / circles * Math.PI * 2 + t * 0.7;
      const r       = baseRadius * Math.min(w,h) / dpr + Math.sin(t + i) * 40;
      const x       = Math.cos(angle) * r;
      const y       = Math.sin(angle) * r;
      const size    = (30 + Math.sin(t*1.2 + i*0.7) * 20) * (1 + sizeMod*Math.sin(t*0.3+i));
      const hue     = (t * hueSpeed + i * 50) % 360;

      const g = ctx.createRadialGradient(x,y,0, x,y,size);
      g.addColorStop(0, `hsla(${hue},100%,65%,0.95)`);
      g.addColorStop(1, `hsla(${(hue+180)%360},100%,15%,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Main animation loop
  function draw(now) {
    const t = now * 0.001; // ms â†’ s

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Paint multiple mirrored slices to build kaleidoscope.
    ctx.save();
    ctx.translate(midX, midY);

    const {slices, swirlSpeed} = parms;
    const sliceAngle = Math.PI * 2 / slices;

    for (let s = 0; s < slices; s++) {
      ctx.save();
      ctx.rotate(sliceAngle * s + t * swirlSpeed);
      // Mirror every second slice for sharper symmetry
      if (s & 1) ctx.scale(-1, 1);
      drawMotif(t);
      ctx.restore();
    }
    ctx.restore();

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
