'use server';
import 'server-only';

import { GoogleGenAI } from '@google/genai';
import type { ImageGenerationSettings, ImageOutputData } from '@/types';
import { logAIGeneral } from '@/lib/ai-logger';
import { uploadGeneratedImages } from './image-storage';

// Initialize Google Generative AI client
let genAI: GoogleGenAI | null = null;

function initializeGenAI() {
  if (!genAI) {
    const apiKey = process.env.GOOGLE_GENAI_API_KEY;
    if (!apiKey) {
      throw new Error('GOOGLE_GENAI_API_KEY not found in environment variables');
    }
    genAI = new GoogleGenAI({ apiKey });
  }
  return genAI;
}

export interface ImageGenerationRequest {
  prompt: string;
  settings?: ImageGenerationSettings;
  userId?: string;
  documentId?: string;
  stageId?: string;
}

export async function generateImages(request: ImageGenerationRequest): Promise<ImageOutputData> {
  const client = initializeGenAI();
  
  logAIGeneral('üé® [Image Generation] Starting generation', {
    provider: request.settings?.provider || 'imagen',
    aspectRatio: request.settings?.aspectRatio || '1:1',
    numberOfImages: request.settings?.numberOfImages || 4,
    promptLength: request.prompt.length
  });

  const provider = request.settings?.provider || 'imagen';
  
  if (provider === 'imagen') {
    return await generateWithImagen(client, request);
  } else {
    // Gemini image generation is not available in many regions
    // We'll default to Imagen even if Gemini is requested
    logAIGeneral('‚ö†Ô∏è [Image Generation] Gemini requested but using Imagen due to regional restrictions');
    return await generateWithImagen(client, request);
  }
}

async function generateWithImagen(client: GoogleGenAI, request: ImageGenerationRequest): Promise<ImageOutputData> {
  try {
    const settings: ImageGenerationSettings = request.settings || {};
    const aspectRatio = settings.aspectRatio || '1:1';
    const numberOfImages = settings.numberOfImages || 4;
    
    logAIGeneral('üñºÔ∏è [Imagen] Generating images', {
      model: 'imagen-3.0-generate-002',
      aspectRatio,
      numberOfImages,
      prompt: request.prompt.substring(0, 100) + '...'
    });

    const startTime = Date.now();
    
    // Generate images using Imagen 3
    const result = await client.models.generateImages({
      model: 'models/imagen-3.0-generate-002', // Full model name with 'models/' prefix
      prompt: request.prompt,
      config: {
        numberOfImages,
        aspectRatio,
        personGeneration: settings.imagen?.personGeneration || 'allow_adult',
        ...(settings.negativePrompt && { negativePrompt: settings.negativePrompt })
      }
    });

    const genTime = Date.now() - startTime;
    logAIGeneral('‚úÖ [Imagen] Generation completed', {
      generationTime: `${genTime}ms`,
      imagesReturned: result.generatedImages?.length || 0
    });

    // Convert Imagen response to our format and immediately upload to storage
    const images: ImageOutputData['images'] = [];
    
    if (result.generatedImages && result.generatedImages.length > 0) {
      // Create data URLs first
      const dataUrls: string[] = [];
      for (const imagenImage of result.generatedImages) {
        if (imagenImage.image?.imageBytes) {
          dataUrls.push(`data:image/png;base64,${imagenImage.image.imageBytes}`);
        }
      }

      // NO FALLBACKS! Storage MUST work!
      if (!request.documentId || !request.stageId) {
        throw new Error('FATAL: documentId and stageId are REQUIRED for image generation');
      }
      
      // Generate a server user ID if not provided (for unauthenticated users)
      const userId = request.userId || `server_user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      logAIGeneral('üîê [Imagen] Using userId', {
        userId,
        wasGenerated: !request.userId
      });

      if (dataUrls.length === 0) {
        throw new Error('FATAL: No images were generated by Imagen');
      }

      logAIGeneral('üöÄ [Imagen] Uploading images to asset storage', {
        imageCount: dataUrls.length,
        userId: userId,
        documentId: request.documentId,
        stageId: request.stageId
      });

      const uploadResults = await uploadGeneratedImages(
        dataUrls,
        userId,
        request.documentId,
        request.stageId,
        request.prompt,
        'imagen-3.0-generate-002'
      );

      if (uploadResults.length === 0) {
        throw new Error('FATAL: Failed to upload ANY images to Firebase Storage');
      }

      // Build ImageOutputData with asset URLs
      for (let i = 0; i < uploadResults.length; i++) {
        const uploadResult = uploadResults[i];
        if (!uploadResult.publicUrl) {
          throw new Error(`FATAL: No public URL for uploaded image ${i}`);
        }
        images.push({
          assetId: uploadResult.assetId,
          publicUrl: uploadResult.publicUrl,
          storageUrl: uploadResult.storageUrl,
          promptUsed: request.prompt,
          mimeType: 'image/png',
          aspectRatio
        });
      }

      logAIGeneral('‚úÖ [Imagen] All images uploaded to asset storage', {
        imageCount: images.length,
        assetIds: images.map(img => img.assetId)
      });
    }

    logAIGeneral('üì¶ [Imagen] Returning asset-based image data', {
      imageCount: images.length,
      publicUrls: images.map(img => img.publicUrl!)
    });

    return {
      provider: 'imagen',
      images,
      selectedImageIndex: 0
    };
    
  } catch (error: any) {
    logAIGeneral('‚ùå [Imagen] Generation failed', {
      error: error.message,
      code: error.code,
      details: error.details
    });
    
    throw new Error(`Image generation failed: ${error.message}`);
  }
}

// Note: Gemini image generation implementation would go here
// but is not included due to regional restrictions
async function generateWithGemini(client: GoogleGenAI, request: ImageGenerationRequest): Promise<ImageOutputData> {
  throw new Error('Gemini image generation is not available in your region. Please use Imagen instead.');
}